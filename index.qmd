---
title: "Selection Bias & Missing Data Challenge - Part 2"
subtitle: "Creating a Statistics Meme: Visualizing Selection Bias"
format:
  html: default
jupyter: misy331_base
execute:
  echo: false
  eval: true
python: /opt/anaconda3/envs/misy331_base/bin/python
---

# ðŸŽ¨ Selection Bias & Missing Data Challenge - Part 2


## The Problem: Visualizing Selection Bias

Selection bias occurs when observed data isn't representative of the population. Your meme will show:

- **Reality**: Your original image (truth)
- **Your Model**: Your stippled image (representation)
- **Selection Bias**: A bold letter "S" (systematic missing data pattern)
- **Estimate**: Stippled image with "S" mask applied (biased estimate)

**Key Concept:** Images are simply matricesâ€”2D arrays where each value represents a pixel (0.0 = black, 1.0 = white). Your stippled image is a matrix with black dots (data points) on a white background. Selection bias removes some of these pixels (data points) in a systematic pattern (the "S"), creating a biased estimate. You'll use image composition tools (matplotlib in Python, imager in R) to arrange these matrices into a memorable visualization.


![Exemplar statistics meme showing the four-panel structure: Reality (original image), Your Model (stippled version), Selection Bias (letter S), and Estimate (masked stippled image)](statistics_meme.png)

### Step 1: Load Images


```{python}
#| label: load-images
#| echo: false
#| eval: false
#| jupyter: misy331_base

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
#import misy331_base

# Load original image
original_img = Image.open('stippleChallenge/dart.jpeg')
if original_img.mode != 'L':
    original_img = original_img.convert('L')
original_array = np.array(original_img, dtype=np.float32) / 255.0

# Load stippled image (from Part 1 - see https://flyaflya.github.io/stippleChallenge/)
# Note: You may need to save stipple_pattern from stippleChallenge first using:
# np.save('stippleChallenge/stippleImage.npy', stipple_pattern)
stipple_array = np.load('stippleChallenge/stippleImage.npy')

print(f"Original: {original_array.shape}, Stipple: {stipple_array.shape}")
```


```{python}
#| label: create-s-letter
#| echo: false
#| eval: false

import numpy as np
from PIL import Image, ImageDraw, ImageFont

# Get image dimensions from the stippled image
h, w = stipple_array.shape

# Create a white background image
s_img = Image.new('L', (w, h), color=255)  # 'L' mode = grayscale, 255 = white
draw = ImageDraw.Draw(s_img)

# Calculate font size (80-90% of image height)
font_size = int(h * 0.85)

# Try to use a bold font, fallback to default if not available
try:
    # Try common bold font paths
    font = ImageFont.truetype("/System/Library/Fonts/Supplemental/Arial Bold.ttf", font_size)
except:
    try:
        font = ImageFont.truetype("/System/Library/Fonts/Helvetica.ttc", font_size)
    except:
        try:
            font = ImageFont.truetype("arial.ttf", font_size)
        except:
            # Fallback to default font
            font = ImageFont.load_default()

# Get text bounding box to center it
text = "S"
# Get text size
try:
    bbox = draw.textbbox((0, 0), text, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
except:
    # Fallback for older PIL versions
    text_width, text_height = draw.textsize(text, font=font)

# Calculate position to center the text
x = (w - text_width) // 2
y = (h - text_height) // 2

# Draw the letter "S" in black (0 = black in grayscale)
draw.text((x, y), text, fill=0, font=font)  # fill=0 means black

# Convert to numpy array and normalize to [0, 1] range
# Invert so that black (0) becomes 0.0 and white (255) becomes 1.0
s_array = np.array(s_img, dtype=np.float32) / 255.0

print(f"S letter matrix shape: {s_array.shape}")
print(f"S letter value range: [{s_array.min():.3f}, {s_array.max():.3f}]")
```
```{python}
#| label: create-masked-estimate
#| echo: false
#| eval: false

import numpy as np
import matplotlib.pyplot as plt

# Create binary mask from "S" image
# Pixels < 0.5 are part of the "S" (black = missing data)
threshold = 0.5
s_mask = s_array < threshold  # True where "S" is black (missing data)

print(f"Mask shape: {s_mask.shape}")
print(f"Number of pixels in 'S' (missing data): {s_mask.sum()}")
print(f"Percentage of image masked: {100 * s_mask.sum() / s_mask.size:.1f}%")

# Apply mask to stippled image
# Where "S" is black (mask is True), remove stipples by setting to white (1.0)
# Where "S" is white (mask is False), keep original stipple values
masked_estimate = np.where(s_mask, 1.0, stipple_array)

print(f"Masked estimate shape: {masked_estimate.shape}")
print(f"Masked estimate value range: [{masked_estimate.min():.3f}, {masked_estimate.max():.3f}]")

```


```{python}
#| label: assemble-meme
#| echo: false
#| eval: false
#| fig-cap: "Four-panel statistics meme demonstrating selection bias"

import numpy as np
import matplotlib.pyplot as plt

# Determine layout based on image dimensions
h, w = original_array.shape
aspect_ratio = w / h

# Choose layout: 1Ã—4 for wide images, 2Ã—2 for square/tall images
if aspect_ratio > 1.5:
    # Wide image: use 1Ã—4 horizontal layout
    fig, axes = plt.subplots(1, 4, figsize=(16, 4))
    layout = 'horizontal'
else:
    # Square or tall image: use 2Ã—2 grid layout
    fig, axes = plt.subplots(2, 2, figsize=(10, 10))
    axes = axes.flatten()  # Flatten to 1D array for easier indexing
    layout = 'grid'

# Set light pink background
fig.patch.set_facecolor('#FFE5E5')  # Light pink background

# Panel 1: Reality (Original Image)
axes[0].imshow(original_array, cmap='gray', vmin=0, vmax=1)
axes[0].axis('off')
axes[0].set_title('Reality', fontsize=16, fontweight='bold', pad=10)

# Panel 2: Your Model (Stippled Image)
axes[1].imshow(stipple_array, cmap='gray', vmin=0, vmax=1)
axes[1].axis('off')
axes[1].set_title('Your Model', fontsize=16, fontweight='bold', pad=10)

# Panel 3: Selection Bias (Letter "S")
axes[2].imshow(s_array, cmap='gray', vmin=0, vmax=1)
axes[2].axis('off')
axes[2].set_title('Selection Bias', fontsize=16, fontweight='bold', pad=10)

# Panel 4: Estimate (Masked Stippled Image)
axes[3].imshow(masked_estimate, cmap='gray', vmin=0, vmax=1)
axes[3].axis('off')
axes[3].set_title('Estimate', fontsize=16, fontweight='bold', pad=10)

# Minimize spacing between panels
plt.tight_layout(pad=0.5)
plt.subplots_adjust(wspace=0, hspace=0.2)

# Save the meme with high DPI
meme_filename = 'statistics_meme.png'
plt.savefig(meme_filename, dpi=200, bbox_inches='tight', facecolor='#FFE5E5', edgecolor='none')
print(f"Meme saved as '{meme_filename}' with 200 DPI")

# Display the meme
plt.show()
```

## Understanding Selection Bias

Selection bias happens when the data you observe is not representative of the population you want to study. 

**Reality (Panel 1):** The original image represents the true populationâ€”the complete picture of what we want to understand.

**Your Model (Panel 2):** The stippled image represents your data collection method. Each black dot is a data point you've sampled. While not perfect, it captures the essential features of the original image.

**Selection Bias (Panel 3):** The letter "S" represents a systematic pattern of missing data. Just like selection bias in real research, this isn't randomâ€”it follows a specific pattern that excludes certain parts of the population.

**Estimate (Panel 4):** When you analyze only the data that remains after selection bias removes observations in the "S" pattern, you get a distorted view of reality. The estimate looks different from both the original image and your model because important information has been systematically excluded.

### Why This Matters

Selection bias can lead to incorrect conclusions. For example:
- **Survey bias**: If you only survey people who answer their phones, you miss those who don't
- **Survivorship bias**: Studying only successful companies misses the lessons from failures
- **Self-selection bias**: People who volunteer for studies may differ from those who don't

It is important that the sample matches the population of interest.

This visualization shows why it is important to check for patterns of missing information that could distort your understanding of reality.

